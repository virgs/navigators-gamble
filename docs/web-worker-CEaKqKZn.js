(function(){"use strict";const C=i=>new Promise(e=>setTimeout(e,i));var f=(i=>(i[i.PURE_MONTE_CARLO_TREE_SEARCH=0]="PURE_MONTE_CARLO_TREE_SEARCH",i))(f||{});class I{first;second;_id;constructor(e,t){this.first=e,this.second=t,this._id=`${e.id}-${t.id}`}get id(){return this._id}getVertices(){return[this.first,this.second]}}class O{_id;links;_position;_ownerId;_direction;constructor(e,t,r,s){this._id=e,this._position=t,this._direction=s,this._ownerId=r,this.links=[]}get position(){return this._position}linkTo(e){const t=new I(this,e);this.links.push(t),e.links.push(t)}getLinkTo(e){return this.links.find(t=>t.getVertices().includes(e))}hasCardOn(){return this._direction!==void 0}get direction(){return this._direction}set direction(e){this._direction=e}get ownerId(){return this._ownerId}set ownerId(e){this._ownerId=e}get id(){return this._id}getLinkedVertices(){return this.links.map(e=>({vertix:e.getVertices().find(r=>r.id!==this._id),link:e}))}getLinkedVerticesWithDirection(){return this.getLinkedVertices().filter(e=>e.vertix.direction!==void 0)}}var E=(i=>(i[i.NORTH=0]="NORTH",i[i.NORTH_EAST=1]="NORTH_EAST",i[i.EAST=2]="EAST",i[i.SOUTH_EAST=3]="SOUTH_EAST",i[i.SOUTH=4]="SOUTH",i[i.SOUTH_WEST=5]="SOUTH_WEST",i[i.WEST=6]="WEST",i[i.NORTH_WEST=7]="NORTH_WEST",i))(E||{});const u=Object.keys(E).filter(i=>!isNaN(Number(i))).map(i=>Number(i)),g=(i,e)=>i===(e-1+u.length)%u.length,_=(i,e)=>g(e,i);var p=(i=>(i.CANCEL="CANCEL",i.PAIR="PAIR",i.SEQUENCE="SEQUENCE",i.BONUS="BONUS",i))(p||{});class M{verticesMap;constructor(e){this.verticesMap=e}calculateMoveScore(e){const t=this.verticesMap[e.vertixId];return t.getLinkedVerticesWithDirection().filter(s=>{const n=s.vertix.direction,o=e.direction;return Math.abs(n-o)===u.length/2}).map(s=>({scoreType:p.CANCEL,vertices:[t,s.vertix],points:2}))}}class T{verticesMap;constructor(e){this.verticesMap=e}calculateMoveScore(e){const t=this.verticesMap[e.vertixId];return t.getLinkedVerticesWithDirection().filter(s=>s.vertix.direction===e.direction).map(s=>({scoreType:p.PAIR,vertices:[t,s.vertix],points:1}))}}class k{seenKeys=new Set;merge(e,t){const r=[];if(e.length===0||t.length===0){const s=e.concat(t);return this.filterUniqueSequences(s)}for(const s of t)for(const n of e){const o=n.findIndex(l=>!s.includes(l)),c=o===-1?[]:n.slice(o),a=[...s,...c],d=a.map(l=>l.id).join("-");this.seenKeys.has(d)||(this.seenKeys.add(d),r.push(a))}return r}filterUniqueSequences(e){const t=[];for(const r of e){const s=r.map(n=>n.id).join("-");this.seenKeys.has(s)||(this.seenKeys.add(s),t.push(r))}return t}}class m{seenSequences=new Set;findUniqueSequences(e,t){return this.explore(e,t)}explore(e,t){const r=e[e.length-1],s=[],n=e.map(a=>a.id).join("-");if(this.seenSequences.has(n))return[];this.seenSequences.add(n);const c=r.getLinkedVerticesWithDirection().filter(a=>t(r.direction,a.vertix.direction)).filter(a=>!e.some(d=>d.id===a.vertix.id));if(c.length===0)return[e];for(const a of c){const d=[...e,a.vertix];s.push(...this.explore(d,t))}return s}}class N{verticesMap;merger;constructor(e){this.verticesMap=e,this.merger=new k}calculateMoveScore(e){const t=this.verticesMap[e.vertixId],s=new m().findUniqueSequences([t],g),o=new m().findUniqueSequences([t],_).map(c=>c.reverse());return this.merger.merge(s,o).filter(c=>c.length>=3).map(c=>({scoreType:p.SEQUENCE,points:c.length,vertices:c}))}}class y{verticesMap;moveScoreCheckers;constructor(e){this.verticesMap=e,this.moveScoreCheckers=[new T(this.verticesMap),new M(this.verticesMap),new N(this.verticesMap)]}clone(){return v.deserialize(v.serialize(this))}getVertices(){return Object.values(this.verticesMap)}getEmptyVertices(){return this.getVertices().filter(e=>e.direction===void 0)}makeMove(e){const t=this.verticesMap[e.vertixId];if(t.direction!==void 0)throw new Error(`Vertix ${e.vertixId} already has a card`);return t.direction=e.direction,this.moveScoreCheckers.map(s=>s.calculateMoveScore(e)).filter(s=>s.length>0).flat()}}class v{static deserialize(e){const t={};return e.vertices.forEach(r=>{t[r.id]=new O(r.id,r.position,r.ownerId,r.direction)}),e.vertices.forEach(r=>{r.linkedVertices.forEach(s=>{t[r.id].linkTo(t[s])})}),new y(t)}static serialize(e){return{vertices:e.getVertices().map(t=>({id:t.id,position:t.position,direction:t.direction,ownerId:t.ownerId,linkedVertices:t.getLinkedVertices().map(r=>r.vertix.id)}))}}}var h=(i=>(i[i.CONFIGURATION=0]="CONFIGURATION",i[i.MOVE_REQUEST=1]="MOVE_REQUEST",i[i.MOVE_RESPONSE=2]="MOVE_RESPONSE",i[i.READY=3]="READY",i))(h||{});class x{gameConfig;aiPlayerId;playersIds;playerTurnOrder;iterationsPerAlternative;gameCards;constructor(e){this.gameConfig=e.gameConfig,this.iterationsPerAlternative=e.configuration.iterationsPerAlternative,this.aiPlayerId=e.playerId,this.playersIds=e.playersIds,this.playerTurnOrder=e.turnOrder,this.gameCards=u.flatMap(t=>Array(this.gameConfig.cardsPerDirection).fill(t))}async makeMove(e){const t=v.deserialize(e.board),r=this.findNextMoveAlternatives(this.aiPlayerId,e.playerCards,t),s=new Map;for(let o=0;o<Math.max(this.iterationsPerAlternative,1);o++){const c=o%r.length,a=r[c],d=this.simulateRandomGame(a,e,t.clone()),l=s.get(c);s.set(c,{...a,score:(l?.score??0)+d})}const n=[...s.values()].reduce((o,c)=>c.score>o.score?c:o,{score:Number.NEGATIVE_INFINITY});return{messageType:h.MOVE_RESPONSE,id:e.id,move:{vertixId:n.vertixId,direction:n.direction,cardIndex:e.playerCards.indexOf(n.direction),playerId:this.aiPlayerId}}}simulateRandomGame(e,t,r){let s=this.playerTurnOrder,n=e,o=[...t.playerCards];const c={...t.currentScores},a=this.computeNotPlayedCards(r,o);for(;r.getEmptyVertices().length>0;){const d=r.makeMove(n);s===this.playerTurnOrder&&(o=this.updateCardsAfterMove(o,n.direction,a.pop())),c[this.aiPlayerId]+=this.calculateScore(d,n.playerId),s=(s+1)%this.playersIds.length;const l=this.findNextMoveAlternatives(this.playersIds[s],s===this.playerTurnOrder?o:a,r);n=l[Math.floor(Math.random()*l.length)]}return r.getVertices().forEach(d=>{d.ownerId!==void 0&&(c[d.ownerId]+=d.direction!==void 0?1:0)}),Object.keys(c).reduce((d,l)=>d+(l===this.aiPlayerId?c[l]:-c[l]),0)}updateCardsAfterMove(e,t,r){const s=e.indexOf(t);return e.filter((n,o)=>o!==s).concat(r??[])}calculateScore(e,t){return e.reduce((r,s)=>(s.vertices.forEach(n=>n.ownerId=t),r+s.points),0)}computeNotPlayedCards(e,t){const r=[...this.gameCards];return e.getVertices().filter(n=>n.direction!==void 0).map(n=>n.direction).concat(t).forEach(n=>{const o=r.indexOf(n);o>=0&&r.splice(o,1)}),r}findNextMoveAlternatives(e,t,r){const s=r.getEmptyVertices(),n=[];return t.forEach((o,c)=>{for(const a of s)n.find(d=>d.direction===o&&d.vertixId===a.id)||n.push({vertixId:a.id,direction:o,playerId:e,cardIndex:c})}),n}}const A={id:"ready",messageType:h.READY};postMessage(A);let S;const R=1e3;self.onmessage=async i=>{try{switch(i.data.messageType){case h.CONFIGURATION:const e=i.data;e.configuration.aiAlgorithm===f.PURE_MONTE_CARLO_TREE_SEARCH&&(S=new x(e));break;case h.MOVE_REQUEST:const[,t]=await Promise.all([C(R),S.makeMove(i.data)]);self.postMessage(t);break}}catch(e){console.log("WW got exception",i.data),console.error(e),self.postMessage(e)}}})();
