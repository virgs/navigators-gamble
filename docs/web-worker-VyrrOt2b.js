(function(){"use strict";const O=r=>new Promise(e=>setTimeout(e,r));var g=(r=>(r[r.PURE_MONTE_CARLO_TREE_SEARCH=0]="PURE_MONTE_CARLO_TREE_SEARCH",r))(g||{});class _{first;second;_id;constructor(e,t){this.first=e,this.second=t,this._id=`${e.id}-${t.id}`}get id(){return this._id}getVertices(){return[this.first,this.second]}}class M{_id;links;_position;_ownerId;_direction;constructor(e,t,s,i){this._id=e,this._position=t,this._direction=i,this._ownerId=s,this.links=[]}get position(){return this._position}linkTo(e){const t=new _(this,e);this.links.push(t),e.links.push(t)}getLinkTo(e){return this.links.find(t=>t.getVertices().includes(e))}hasCardOn(){return this._direction!==void 0}get direction(){return this._direction}set direction(e){this._direction=e}get ownerId(){return this._ownerId}set ownerId(e){this._ownerId=e}get id(){return this._id}getLinkedVertices(){return this.links.map(e=>({vertix:e.getVertices().find(s=>s.id!==this._id),link:e}))}getLinkedVerticesWithDirection(){return this.getLinkedVertices().filter(e=>e.vertix.direction!==void 0)}}var m=(r=>(r[r.NORTH=0]="NORTH",r[r.NORTH_EAST=1]="NORTH_EAST",r[r.EAST=2]="EAST",r[r.SOUTH_EAST=3]="SOUTH_EAST",r[r.SOUTH=4]="SOUTH",r[r.SOUTH_WEST=5]="SOUTH_WEST",r[r.WEST=6]="WEST",r[r.NORTH_WEST=7]="NORTH_WEST",r))(m||{});const p=Object.keys(m).filter(r=>!isNaN(Number(r))).map(r=>Number(r)),S=(r,e)=>r===(e-1+p.length)%p.length,y=(r,e)=>S(e,r);var f=(r=>(r.CANCEL="CANCEL",r.PAIR="PAIR",r.SEQUENCE="SEQUENCE",r.BONUS="BONUS",r))(f||{});class T{verticesMap;constructor(e){this.verticesMap=e}calculateMoveScore(e){const t=this.verticesMap[e.vertixId];return t.getLinkedVerticesWithDirection().filter(i=>{const n=i.vertix.direction,o=e.direction;return Math.abs(n-o)===p.length/2}).map(i=>({scoreType:f.CANCEL,vertices:[t,i.vertix],points:2}))}}class k{verticesMap;constructor(e){this.verticesMap=e}calculateMoveScore(e){const t=this.verticesMap[e.vertixId];return t.getLinkedVerticesWithDirection().filter(i=>i.vertix.direction===e.direction).map(i=>({scoreType:f.PAIR,vertices:[t,i.vertix],points:1}))}}class N{seenKeys=new Set;merge(e,t){const s=[];if(e.length===0||t.length===0){const i=e.concat(t);return this.filterUniqueSequences(i)}for(const i of t)for(const n of e){const o=n.findIndex(h=>!i.includes(h)),c=o===-1?[]:n.slice(o),a=[...i,...c],d=a.map(h=>h.id).join("-");this.seenKeys.has(d)||(this.seenKeys.add(d),s.push(a))}return s}filterUniqueSequences(e){const t=[];for(const s of e){const i=s.map(n=>n.id).join("-");this.seenKeys.has(i)||(this.seenKeys.add(i),t.push(s))}return t}}class C{seenSequences=new Set;findUniqueSequences(e,t){return this.explore(e,t)}explore(e,t){const s=e[e.length-1],i=[],n=e.map(a=>a.id).join("-");if(this.seenSequences.has(n))return[];this.seenSequences.add(n);const c=s.getLinkedVerticesWithDirection().filter(a=>t(s.direction,a.vertix.direction)).filter(a=>!e.some(d=>d.id===a.vertix.id));if(c.length===0)return[e];for(const a of c){const d=[...e,a.vertix];i.push(...this.explore(d,t))}return i}}class x{verticesMap;merger;constructor(e){this.verticesMap=e,this.merger=new N}calculateMoveScore(e){const t=this.verticesMap[e.vertixId],i=new C().findUniqueSequences([t],S),o=new C().findUniqueSequences([t],y).map(c=>c.reverse());return this.merger.merge(i,o).filter(c=>c.length>=3).map(c=>({scoreType:f.SEQUENCE,points:c.length,vertices:c}))}}class A{verticesMap;moveScoreCheckers;constructor(e){this.verticesMap=e,this.moveScoreCheckers=[new k(this.verticesMap),new T(this.verticesMap),new x(this.verticesMap)]}clone(){return v.deserialize(v.serialize(this))}getVertices(){return Object.values(this.verticesMap)}getEmptyVertices(){return this.getVertices().filter(e=>e.direction===void 0)}makeMove(e){const t=this.verticesMap[e.vertixId];if(t.direction!==void 0)throw new Error(`Vertix ${e.vertixId} already has a card`);return t.direction=e.direction,this.moveScoreCheckers.map(i=>i.calculateMoveScore(e)).filter(i=>i.length>0).flat()}}class v{static deserialize(e){const t={};return e.vertices.forEach(s=>{t[s.id]=new M(s.id,s.position,s.ownerId,s.direction)}),e.vertices.forEach(s=>{s.linkedVertices.forEach(i=>{t[s.id].linkTo(t[i])})}),new A(t)}static serialize(e){return{vertices:e.getVertices().map(t=>({id:t.id,position:t.position,direction:t.direction,ownerId:t.ownerId,linkedVertices:t.getLinkedVertices().map(s=>s.vertix.id)}))}}}var u=(r=>(r[r.CONFIGURATION=0]="CONFIGURATION",r[r.MOVE_REQUEST=1]="MOVE_REQUEST",r[r.MOVE_RESPONSE=2]="MOVE_RESPONSE",r[r.READY=3]="READY",r))(u||{});class V{gameConfig;playerId;playersIds;playerTurnOrder;iterationsPerAlternative;gameCards;constructor(e){this.gameConfig=e.gameConfig,this.iterationsPerAlternative=e.configuration.iterationsPerAlternative,this.playerId=e.playerId,this.playersIds=e.playersIds,this.playerTurnOrder=e.turnOrder,this.gameCards=p.flatMap(t=>Array(this.gameConfig.cardsPerDirection).fill(t))}async makeMove(e){const t=v.deserialize(e.board),s=this.findNextMoveAlternatives(this.playerId,e.playerCards,t),i=new Map;for(let o=0;o<this.iterationsPerAlternative;o++){const c=t.clone(),a=Math.floor(Math.random()*s.length),d=s[a],h=this.simulateRandomGame(d,e,c)?1:0;i.has(a)?i.set(a,{...d,score:i.get(a).score+h}):i.set(a,{...d,score:h})}const n=[...i.values()].reduce((o,c)=>c.score>o.score?c:o,{...s[0],score:Number.NEGATIVE_INFINITY});return{messageType:u.MOVE_RESPONSE,id:e.id,move:{vertixId:n.vertixId,direction:n.direction,cardIndex:e.playerCards.indexOf(n.direction),playerId:this.playerId}}}simulateRandomGame(e,t,s){let i=this.playerTurnOrder,n=e,o=[...t.playerCards];const c={...t.currentScores},a=this.computeNotPlayedCards(s,o);for(;s.getEmptyVertices().length>0;){const l=s.makeMove(n);i===this.playerTurnOrder&&(o=this.updateCardsAfterMove(o,n.direction,a.pop())),c[this.playerId]+=this.calculateScore(l,n.playerId),i=(i+1)%this.playersIds.length;const E=this.findNextMoveAlternatives(this.playersIds[i],i===this.playerTurnOrder?o:a,s);n=E[Math.floor(Math.random()*E.length)]}s.getVertices().forEach(l=>{l.ownerId!==void 0&&(c[l.ownerId]+=l.direction?1:0)});const d=c[this.playerId]??0;return Object.entries(c).filter(([l,E])=>l!==this.playerId).every(([,l])=>l<d)}updateCardsAfterMove(e,t,s){const i=e.indexOf(t);return e.filter((n,o)=>o!==i).concat(s??[])}calculateScore(e,t){return e.reduce((s,i)=>(i.vertices.forEach(n=>n.ownerId=t),s+i.points),0)}computeNotPlayedCards(e,t){const s=[...this.gameCards];return e.getVertices().filter(n=>n.direction!==void 0).map(n=>n.direction).concat(t).forEach(n=>{const o=s.indexOf(n);o>=0&&s.splice(o,1)}),s}findNextMoveAlternatives(e,t,s){const i=s.getEmptyVertices(),n=[];return t.forEach((o,c)=>{for(const a of i)n.find(d=>d.direction===o&&d.vertixId===a.id)||n.push({vertixId:a.id,direction:o,playerId:e,cardIndex:c})}),n}}const R={id:"ready",messageType:u.READY};postMessage(R);let I;const w=1e3;self.onmessage=async r=>{try{switch(r.data.messageType){case u.CONFIGURATION:const e=r.data;e.configuration.aiAlgorithm===g.PURE_MONTE_CARLO_TREE_SEARCH&&(I=new V(e));break;case u.MOVE_REQUEST:const[,t]=await Promise.all([O(w),I.makeMove(r.data)]);self.postMessage(t);break}}catch(e){console.log("WW got exception",r.data),console.error(e),self.postMessage(e)}}})();
